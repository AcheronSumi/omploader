#!/bin/env ruby
#
# Copyright 2007-2009 David Shakaryan <omp@gentoo.org>
# Copyright 2007-2009 Brenden Matthews <brenden@rty.ca>
#
# Distributed under the terms of the GNU General Public License v3
#

require 'omploader'

def do_stats
	Cache.set('statstime', Time.now.to_i, Default_cache_expiry_long)
	db = db_connect
	gen_stats = "\t\t\t" + '<div class="title">General Stats</div>' + "\n" +
			"\t\t\t" + '<div class="content">' + "\n" +
			"\t\t\t\t" + '<div class="filelist">' + "\n"
	query = db.prepare('select count(id), sum(size) from metadata;')
	stmt = query.execute
	res = stmt.fetch
	count = res[0]
	size = to_readable_bytes(res[1].to_f)
	query = db.prepare('select count(id) from visitors;')
	stmt = query.execute
	res = stmt.fetch
	visitors = res[0]
	query = db.prepare('select count(id) from comments;')
	stmt = query.execute
	res = stmt.fetch
	comments = res[0]
	gen_stats += "\t\t\t\t\t" + '<div class="file">' + "\n" +
				"\t\t\t\t\t\t" + '<span class="filename"><b>Number of files:</b> </span><span class="filename">' + count.to_s + '</span>' + "\n" +
				"\t\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t\t\t" + '<div class="file">' + "\n" +
				"\t\t\t\t\t\t" + '<span class="filename"><b>Data store size:</b> </span><span class="filename">' + size + '</span>' + "\n" +
				"\t\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t\t\t" + '<div class="file">' + "\n" +
				"\t\t\t\t\t\t" + '<span class="filename"><b>Unique visitors in last ' + (Visitor_expiry/3600).to_s + ' hours:</b> </span><span class="filename">' + visitors.to_s + '</span>' + "\n" +
				"\t\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t\t\t" + '<div class="file">' + "\n" +
				"\t\t\t\t\t\t" + '<span class="filename"><b>Comments:</b> </span><span class="filename">' + comments.to_s + '</span>' + "\n" +
				"\t\t\t\t\t" + '</div>' + "\n"

	gen_stats += "\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t" + '</div>' + "\n"
	stmt.close

	query = db.prepare('select referrers.address, sum(count) from referrals inner join referrers on referrers.id = referrals.referrer_id group by referrals.referrer_id order by sum(count) desc limit 15;')
	stmt = query.execute
	top_refs = "\t\t\t" + '<div class="title">Top Referrers</div>' + "\n" +
				"\t\t\t" + '<div class="content">' + "\n" +
				"\t\t\t\t" + '<div class="filelist">' + "\n"
	stmt.num_rows.times do
		res = stmt.fetch
		address = res[0].to_s
		address.length > 60 ? address_listed = address[0..58] + '…' : address_listed = address
		count = res[1].to_s
		top_refs += "\t\t\t\t\t" + '<div class="file">' + "\n" +
					"\t\t\t\t\t\t" + '<span class="filename"><a href="' + address.gsub(/&/, '&amp;') + '" title="' + address.gsub(/&/, '&amp;') + '">' + address_listed.gsub(/&/, '&amp;') + '</a></span>' + "\n" +
					"\t\t\t\t\t\t" + '<span class="fileinfo">' + count + '</span>' + "\n" +
					"\t\t\t\t\t" + '</div>' + "\n"
	end
	top_refs += "\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t" + '</div>' + "\n"
	stmt.close

	query = db.prepare('select
										metadata.id,
										metadata.comment_count,
										names.name,
										c1.creation_date
									from metadata
										inner join names on names.id = metadata.name_id
										right join comments c1 on c1.metadata_id = metadata.id
										join (select id, max(creation_date) as creation_date from comments group by id order by creation_date desc) as c2 on c2.id = c1.id
									group by metadata.id
									order by c1.creation_date desc
									limit 20')
	stmt = query.execute
	new_disc = "\t\t\t" + '<div class="title">Recently Discussed</div>' + "\n" +
				"\t\t\t" + '<div class="content">' + "\n" +
				"\t\t\t\t" + '<div class="filelist">' + "\n"
	stmt.num_rows.times do
		res = stmt.fetch
		id = res[0].to_s
		count = res[1].to_s
		name = res[2].to_s
		date = res[3].to_s

		if name.length > 50
			name_displayed = name[0..48] + '…'
		else
			name_displayed = name
		end
		new_disc += "\t\t\t\t\t" + '<div class="file">' + "\n" +
					"\t\t\t\t\t\t" + '<span class="filename"><a href="i' + id.to_b64 + '#comment_top" title="' + name + '">' + name_displayed + '</a></span>' + "\n" +
					"\t\t\t\t\t\t" + '<span class="fileinfo">' + count + '</span>' + "\n" +
					"\t\t\t\t\t\t" + '<span class="fileinfo">' + date.sub(' ', '&nbsp;') + '</span>' + "\n" +
					"\t\t\t\t\t" + '</div>' + "\n"
	end
	new_disc += "\t\t\t\t" + '</div>' + "\n" +
				"\t\t\t" + '</div>' + "\n"
	stmt.close

	xhtml = gen_stats + new_disc + top_refs

	Cache.set('stats', Base64.encode64(xhtml_pre + xhtml + xhtml_post), 0)
	return xhtml_pre + xhtml + xhtml_post
end

threads = []

FCGI.each_cgi {|cgi|
	begin
		html = Cache.get('stats')
		time = Cache.get('statstime')
		poo_sent = false
		if !html.nil?
			cgi.out('application/xhtml+xml') { Base64.decode64(html) }
			poo_sent = true
			next if !time.nil? and Time.now.to_i - time.to_i < Default_cache_expiry_long
		end
		if !poo_sent
			cgi.out('application/xhtml+xml') { do_stats() }
		else
			threads << Thread.new { do_stats() }
		end
	rescue Mysql::Error => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Ouch, db error: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue RuntimeError => err
		db.rollback unless db.nil?
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">' + err + '</div>' + xhtml_post
		}
	rescue SyntaxError, NameError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  String won\'t compile: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue StandardError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  Error running script: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue MemCache::MemCacheError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  Error running script: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  This error isn\'t being handled: ' + err + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	end
}

threads.each { |thread| thread.join }
