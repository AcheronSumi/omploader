#!/bin/env ruby
#
# Copyright 2007-2009 David Shakaryan <omp@gentoo.org>
# Copyright 2007-2009 Brenden Matthews <brenden@rty.ca>
#
# Distributed under the terms of the GNU General Public License v3
#

require 'omploader'
require 'filemagic'
require 'rubygems'
require 'curb'
require 'uri'
require 'id3lib'
require 'digest/sha1'
require 'vorbisfile'

def get_output(id, name, name_displayed, type, host)
	ret =	'<div class="upload">View file: <a href="v' + id + '">http://' + host + '/v' + id + '</a><br />' + "\n" +
			'View info: <a href="i' + id + '">http://' + host + '/i' + id + '</a><br />' + "\n" +
			'With name: <a href="v' + id + '/' + name + '">http://' + host + '/v' + id + '/' + name_displayed + '</a><br />' + "\n"
	if type == 'image'
		ret +=	'Thumbnail: <a href="t' + id + '">http://' + host + '/t' + id + '</a><br />' + "\n" +
					'BBCode:<br /><span>[url=http://' + host + '/v' + id + '][img]http://' + host + '/t' + id + '[/img][/url]</span>' + "\n"
	elsif type == 'video'
		ret += 'It may take a while for your video to appear, so check back periodically.' + "\n"
		ret += 'BBCode:<br /><span>[url=http://' + host + '/v' + id + ']http://' + host + '/v' + id + '[/url]</span>' + "\n"
	else
		ret += 'BBCode:<br /><span>[url=http://' + host + '/v' + id + ']http://' + host + '/v' + id + '[/url]</span>' + "\n"
	end
	ret += '</div><br />' + "\n"
	return ret
end

# Method for using Vim's syntax highlighting and improving the generated code.
def vimcolour(datum, filetype, title)
	# Store the datum in a temporary file for Vim to open.
	tempfile = Tempfile.new('vimcolour')
	tempfile.close

	# Map the temporary file into memory to avoid unnecessarily using the hard
	# disk.
	mmap = Mmap.new(tempfile.path, 'rw')
	mmap.insert(0, datum)
	mmap.munmap

	# Set terminal colours to 88 to allow us to use the Inkpot theme.
	# The bdelete command is to delete the first buffer, so the generated HTML
	# does not have to be saved to a different file.
	%x{vim -n -e                      \
		-c 'set t_Co=88'              \
		-c 'syntax on'                \
		-c 'set filetype=#{filetype}' \
		-c 'set number'               \
		-c 'colorscheme inkpot'       \
		-c 'let html_use_css = 1'     \
		-c 'let use_xhtml = 1'        \
		-c 'run syntax/2html.vim'     \
		-c 'bdelete 1'                \
		-c 'wq! #{tempfile.path}'     \
		#{tempfile.path}              }

	# Read the temporary file and split it into three parts, splitting from the
	# first <pre> tag and the last </pre> tag. This creates an array consisting
	# of the pre-code HTML, the code HTML, and the post-code HTML.
	datum = Mmap.new(tempfile.path, 'r').to_str
	datum = datum.split(/<pre>\n/, 2)
	datum = [ datum[0],
		datum[1].reverse.split(/\n>erp\/</, 2)[1].reverse,
		datum[1].reverse.split(/\n>erp\/</, 2)[0].reverse]

	# Remove the XML declaration so that the datum is seen as HTML rather than
	# XML. Modify the pre-code HTML to change the title, as well as improve the
	# CSS code. Create a container division to ensure proper displaying of the
	# line numbers.
	datum[0].sub!(/^<\?xml.*\?>$\n/, '')
	datum[0].sub!(/^(<title>).*(<\/title>)/, "\\1#{title} (VimColour)\\2")
	datum[0].sub!(/^(pre \{).*;/, '\1 margin: 0;')
	datum[0].sub!(/^(body \{.*background-color: #)....../, '\1000000; margin: 0; font-size: 1.2em')
	datum[0].sub!(/^\.lnr( \{.*;)/, "div#container { display: table-row; }\n" + "div#ln\\1 }\ndiv#ln, div#code { display: table-cell;")
	datum[0].gsub!(/ text-decoration: underline;/, '')
	datum[0] += "<div id=\"container\">\n"

	# Modify the main HTML to separate the number lines and the actual code into
	# separate divisions. This allows for aligning them next to each other via
	# the CSS table-cell display property, while still allowing one to select
	# the code while not selecting the numbers.
	ln   = "<div id=\"ln\">\n"
	code = "<div id=\"code\">\n<pre>\n"
	datum[1] = datum[1].each_line { |str|
		if str =~ /^<span class="lnr">( *\d+ )<\/span>/
			ln   += $1.gsub(' ', '&nbsp;') + "<br />\n"
			code += str.gsub(/^<span class="lnr"> *\d+ <\/span>/, '')
		end
	}
	ln   += "</div>\n"
	code += "</pre>\n</div>\n"
	datum[1] = ln + code

	# Close the container division.
	datum[2] = "</div>\n" + datum[2]

	# Return the modified datum as a string.
	return datum.join
end

FCGI.each_cgi {|cgi|
	begin
		db = db_connect

		output = ''
		visitor_id = get_cached_visitor_id(cgi, db)

		owner_id = get_cached_owner_id(cgi, db)

		throttle = Cache.get('throttle' + visitor_id)
		if throttle.nil?
			throttle = 0
		end
		if throttle.to_i > Max_upload_count
			raise 'Slow down there, cowboy.'
		end
		
		db.commit

		saved = 0
		stop = true

		# Verify that a file parameter is present.
		for i in 1...6
			if cgi.has_key?('file' + i.to_s)
				file = cgi['file' + i.to_s]
				datum = file.read
				next if datum.length > Max_file_size or datum.empty?
				name = file.original_filename.chomp
				name = 'ompload' if name !~ /\S/
			elsif cgi.has_key?('url' + i.to_s)
				begin
					url = cgi['url' + i.to_s]
					begin
						# do some checking on our url
						url = URI.escape(url)
						url = URI.extract(url).first
						split = URI.split(url)
						host = split[2]
						next if host == cgi.host
						path = split[5]
						name = URI.unescape(File.basename(path))
						name = url if name !~ /\S/ or name == '/'
					rescue
						next
					end
					next if url == 'URL'
					next if url =~ /^file:\//i
					next if url =~ /127\.0\.0\.1/i
					next if url =~ /:\/\/127\.0\.0\.1\//i
					next if url =~ /:\/\/localhost\//i
					datum = Curl::Easy.perform(url).body_str
					next if datum.length > Max_file_size or datum.empty?
				rescue
					next
				end
			elsif cgi.has_key?('paste')
				syntax = cgi['syntax'].read
				datum = cgi['paste'].read.gsub("\r", '')
				next if datum.length > Max_file_size or datum.empty?
				name = cgi['name'].read
				name = 'pasta' if name !~ /\S/
					if syntax != 'raw'
						datum = vimcolour(datum, syntax, name)
					end
				stop = true
			elsif stop
				break
			else
				next
			end
			name = name.sanitise

			begin
				if cgi.has_key?('paste') and syntax == 'raw'
					content_type = 'text/plain'
				else
					fm = FileMagic.new(FileMagic::MAGIC_MIME)
					content_type = fm.buffer(datum)
				end
				actual_content_type = content_type

				content_type_split = content_type.chomp.split('/', 2)
				actual_content_type_main = content_type_main = content_type_split.first
				actual_content_type_sub = content_type_sub = content_type_split.last

				actual_name = name
				if content_type_main == 'video'
					name = name + '.html'
					actual_content_type = 'text/html'
				end
				query = db.prepare('insert into names (name) values (?) on duplicate key update id = last_insert_id(id)')
				stmt = query.execute(name)
				name_id = stmt.insert_id
				stmt.close

				query = db.prepare('insert into content_types_main (type) values (?) on duplicate key update id = last_insert_id(id)')
				stmt = query.execute(actual_content_type_main)
				content_type_main_id = stmt.insert_id
				stmt.close
				query = db.prepare('insert into content_types_sub (type) values (?) on duplicate key update id = last_insert_id(id)')
				stmt = query.execute(actual_content_type_sub)
				content_type_sub_id = stmt.insert_id
				stmt.close
				query = db.prepare('insert into content_types (content_type_main_id, content_type_sub_id) values (?,?) on duplicate key update id = last_insert_id(id)')
				stmt = query.execute(actual_content_type_main_id, actual_content_type_sub_id)
				content_type_id = stmt.insert_id
				stmt.close

				fingerprint = Digest::SHA1.hexdigest(datum)

				query = db.prepare('insert into metadata (content_type_id, name_id, size, owner_id, fingerprint) values (?,?,?,?,?)')
				stmt = query.execute(content_type_id, name_id, datum.length, owner_id, fingerprint)
				id = stmt.insert_id
				stmt.close

				if content_type == 'audio/mpeg' or content_type == 'application/ogg'
					tmpfile = Tempfile.new(name)
					tmpfile.close
					mmap = Mmap.new(tmpfile.path, 'rw')
					mmap.insert(0, datum)
					mmap.munmap
					if content_type == 'audio/mpeg'
						tag = ID3Lib::Tag.new(tmpfile.path)
						artist = tag.artist.to_s.sanitise
						title = tag.title.to_s.sanitise
						album = tag.album.to_s.sanitise
						year = tag.year.to_s.sanitise
					elsif content_type == 'application/ogg'
						vf = Ogg::VorbisFile.new
						tmpfile.open
						if vf.open(tmpfile)
							comments = vf.comments(-1)
							artist = comments['artist'].to_s.sanitise
							title = comments['title'].to_s.sanitise
							album = comments['album'].to_s.sanitise
							year = comments['date'].to_s.sanitise
						end
					end
					query = db.prepare('insert into names (name) values (?) on duplicate key update id = last_insert_id(id)')
					stmt = query.execute(artist)
					artist_id = stmt.insert_id
					query = db.prepare('insert into names (name) values (?) on duplicate key update id = last_insert_id(id)')
					stmt = query.execute(title)
					title_id = stmt.insert_id
					query = db.prepare('insert into names (name) values (?) on duplicate key update id = last_insert_id(id)')
					stmt = query.execute(album)
					album_id = stmt.insert_id
					query = db.prepare('insert into names (name) values (?) on duplicate key update id = last_insert_id(id)')
					stmt = query.execute(year)
					year_id = stmt.insert_id
					query = db.prepare('update metadata set artist_id = ?, title_id = ?, album_id = ?, year_id = ? where metadata.id = ?')
					stmt = query.execute(artist_id, title_id, album_id, year_id, id)
					stmt.close
				end

				saved = saved + 1

				id = id.to_s.to_b64

				file = File.new(Paths['data'] + '/' + id, File::CREAT|File::TRUNC|File::RDWR, 0664)
				file.close
				mmap = Mmap.new(file.path, 'rw')
				if content_type_main == 'video'
					# o deer, special effects required
					# compose html dealy
					video_html = xhtml_pre +
						'<video src="' + Down_bucket_url + actual_name + '.ogg" controls="true"></video>' + 
						xhtml_post
					query = db.prepare('update metadata set size = ?, listed = ? where metadata.id = ?')
					stmt = query.execute(video_html.length, 0, id)
					stmt.close
					file = File.new(Paths['video_up_data'] + '/' + id + '-' + actual_name, File::CREAT|File::TRUNC|File::RDWR, 0664)
					file.close
					mmap2 = Mmap.new(file.path, 'rw')
					mmap2.insert(0, datum)
					mmap2.munmap
					mmap.insert(0, video_html)
				else
					mmap.insert(0, datum)
				end
				mmap.munmap
				if name.length > 15
					name_displayed = name[0..13] + '…'
				else
					name_displayed = name
				end
				output = output + get_output(id, name, name_displayed, content_type_main, cgi.host)
			rescue Mysql::Error => err
				db.rollback
				if err.errno == 1062
					# duplicate key
					# get id for the dupe one
					query = db.prepare('select metadata.id, names.name from metadata inner join names on names.id = metadata.name_id where metadata.fingerprint = ?')
					stmt = query.execute(fingerprint)
					res = stmt.fetch
					stmt.close
					old_id = res[0].to_s.to_b64
					name = res[1].to_s
					if name.length > 15
						name_displayed = name[0..13] + '…'
					else
						name_displayed = name
					end
					output = output + get_output(old_id, name, name_displayed, '', cgi.host)
					saved += 1
					db.commit
					next
				else
					raise err
				end
			end
			db.commit
		end
		if saved < 1
			raise 'You are a trad.'
		end
		Cache.set('throttle' + visitor_id, throttle.to_i + 1, Max_upload_period)
		db.commit
		cgi.out {
			xhtml_pre +
			'        <div class="content large">' + "\n" +
			'          omploaded!<br />' + "\n" +
			'          <br />' + "\n" +
			output +
			'        </div>' + "\n" +
			xhtml_post
		}
	rescue Mysql::Error => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Ouch, db error: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue RuntimeError => err
		db.rollback unless db.nil?
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">' + err + '</div>' + xhtml_post
		}
	rescue SyntaxError, NameError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  String won\'t compile: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue StandardError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  Error running script: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue MemCache::MemCacheError => err
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  Error running script: ' + errmsg + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	rescue
		db.rollback unless db.nil?
		if Debug
			errmsg = err.to_s + '<br />' + err.backtrace.join('<br />')
		else
			errmsg = err.to_s
		end
		cgi.out('application/xhtml+xml') {
			xhtml_pre + '        <div class="content large">Oops, we screwed up.  This error isn\'t being handled: ' + err + '</div>' + xhtml_post
		}
		log = Logger.new(Paths['log'])
		log.error(cgi.host)
		log.error(cgi.script_name)
		log.error(cgi.params)
		log.error(err)
	ensure
		tmpfile.close! unless tmpfile.nil?
		db.close if db
	end
}

